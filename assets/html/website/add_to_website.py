
"""
Utility to generate HTML snippets that match the video grids used in `website.html`.

The main helper, `build_video_grid_section`, takes a section title, description,
and a 2D list of video sources and emits a ready-to-insert HTML string that
includes the title, description, and a responsive video grid. Cells can contain
either a single video URL (string) or a list of URLs; list cells are rendered
as a "roundabout" (rotating options with prev/next buttons) similar to the
baseline carousels in the site.
"""

from __future__ import annotations

import html
import uuid
from typing import Dict, List, Optional, Sequence, Union


VideoCell = Union[str, Sequence[str]]


def _escape(text: str) -> str:
    """HTML-escape helper."""
    return html.escape(text, quote=True)


def _indent_block(text: str, level: int) -> str:
    """Indent every line in text by `level` tabs (4 spaces for readability)."""
    prefix = "    " * level
    return "\n".join(f"{prefix}{line}" if line else "" for line in text.split("\n"))


def build_video_grid_section(
    title: str,
    description: str,
    video_rows: List[List[VideoCell]],
    prompts: Optional[List[str]] = None,
    column_headers: Optional[List[str]] = None,
    roundabout_titles: Optional[Dict[int, List[str]]] = None,
    container_id: Optional[str] = None,
) -> str:
    """
    Build an HTML section containing a title, description, and a grid of videos.

    Args:
        title: Section heading.
        description: Short paragraph shown under the heading.
        video_rows: 2D list of videos. Each cell can be:
            - str: single video source URL.
            - list/tuple of str: multiple sources for this cell; renders as a
              roundabout (prev/next) with the same option count across rows
              for that column.
        prompts: Optional list of per-row prompts shown in a collapsible
            <details> element. Length must match the number of rows if set.
        column_headers: Optional list of column labels; length must match the
            number of columns.
        roundabout_titles: Optional mapping of column index -> list of titles
            for the rotating options in that column. If omitted, a default
            "(Click < or > to see more)" prefix is used with numbered options.
        container_id: Optional stable id prefix; autogenerated if None.

    Returns:
        A string containing the HTML section that mirrors the grids in
        `website.html`, including the roundabout JavaScript for any rotating
        columns.
    """

    if not video_rows or not all(video_rows):
        raise ValueError("video_rows must be a non-empty 2D list")

    num_cols = len(video_rows[0])
    if any(len(r) != num_cols for r in video_rows):
        raise ValueError("All rows in video_rows must have the same length")

    if column_headers and len(column_headers) != num_cols:
        raise ValueError("column_headers length must match number of columns")

    if prompts and len(prompts) != len(video_rows):
        raise ValueError("prompts length must match number of rows in video_rows")

    container_id = container_id or f"grid_{uuid.uuid4().hex[:8]}"
    roundabout_titles = roundabout_titles or {}

    # Identify rotating columns and validate option counts.
    rotating_cols = {}
    for col_idx in range(num_cols):
        # Determine if any row for this column contains multiple options.
        options_per_row: List[int] = []
        for row in video_rows:
            cell = row[col_idx]
            if isinstance(cell, (list, tuple)):
                options_per_row.append(len(cell))
            else:
                options_per_row.append(1)
        if max(options_per_row) > 1:
            if len(set(options_per_row)) != 1:
                raise ValueError(
                    f"All rows in column {col_idx} must have the same number of "
                    "options when using roundabout columns"
                )
            rotating_cols[col_idx] = options_per_row[0]

    def render_header_row() -> str:
        if not column_headers:
            return ""
        cell_blocks = []
        for idx, header in enumerate(column_headers):
            if idx in rotating_cols:
                titles = roundabout_titles.get(idx) or [
                    f"(Click < or > to see more) Option {i+1}"
                    for i in range(rotating_cols[idx])
                ]
                header_inner = "\n".join(
                    [
                        '<div style="font-size: 16px; margin-top: 5px; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 16px;">',
                        f'    <span role="button" aria-label="Previous" onclick="rotateLeft_{container_id}_{idx}()" style="cursor: pointer; font-size: 22px; font-weight: bold;">&#x2039;</span>',
                        f'    <span id="{container_id}_{idx}_title" style="min-width: 160px; text-align: center; display: inline-block; white-space: pre-wrap;">{_escape(titles[0])}</span>',
                        f'    <span role="button" aria-label="Next" onclick="rotateRight_{container_id}_{idx}()" style="cursor: pointer; font-size: 22px; font-weight: bold;">&#x203A;</span>',
                        "</div>",
                    ]
                )
            else:
                header_inner = (
                    '<div style="font-size: 16px; margin-top: 5px; font-weight: bold;">'
                    f"{_escape(header)}</div>"
                )

            cell_blocks.append(
                "\n".join(
                    [
                        '<div class="column px-4" style="margin: 0; '
                        f'width: {100/num_cols:.6f}%; display: block;">',
                        '    <div class="row text-center" style="display: flex; flex-direction: column; align-items: center; justify-content: center;">',
                        _indent_block(header_inner, 2),
                        "    </div>",
                        "</div>",
                    ]
                )
            )

        return "\n".join(
            [
                '<div class="row" style="display: flex; align-items: flex-start; flex-wrap: nowrap;">',
                _indent_block("\n".join(cell_blocks), 1),
                "</div>",
            ]
        )

    def render_video_cell(row_idx: int, col_idx: int, cell: VideoCell) -> str:
        if col_idx in rotating_cols:
            videos = cell if isinstance(cell, (list, tuple)) else [cell]
            snippets = []
            for option_idx, src in enumerate(videos):
                display = "block" if option_idx == 0 else "none"
                snippets.append(
                    f'<video id="{container_id}_r{row_idx}_c{col_idx}_k{option_idx}" autoplay="autoplay" controls="controls" loop="loop" muted="muted" src="{_escape(str(src))}" style="width: 100%; height: auto; display: {display};" type="video/mp4"></video>'
                )
            return "\n".join(snippets)

        src = cell[0] if isinstance(cell, (list, tuple)) else cell
        return (
            '<video autoplay="autoplay" controls="controls" loop="loop" muted="muted" '
            f'src="{_escape(str(src))}" style="width: 100%; height: auto; display: block;" '
            'type="video/mp4"></video>'
        )

    def render_rows() -> str:
        rows_html: List[str] = []
        for row_idx, row in enumerate(video_rows):
            cell_blocks = []
            for col_idx, cell in enumerate(row):
                cell_blocks.append(
                    "\n".join(
                        [
                            '<div class="column px-4" style="margin: 0; '
                            f'width: {100/num_cols:.6f}%;">',
                            '    <div class="row text-center" style="display: flex; flex-direction: column; align-items: center; justify-content: center;">',
                            _indent_block(render_video_cell(row_idx, col_idx, cell), 2),
                            "    </div>",
                            "</div>",
                        ]
                    )
                )

            row_block = "\n".join(
                [
                    '<div class="row" style="display: flex; align-items: flex-start;">',
                    _indent_block("\n".join(cell_blocks), 1),
                    "</div>",
                ]
            )
            rows_html.append(row_block)

            if prompts and prompts[row_idx]:
                prompt_html = "\n".join(
                    [
                        '<div class="row" style="display: flex; justify-content: center;">',
                        '    <div class="column px-4" style="margin: 0; width: 100%;">',
                        '        <div class="row text-center" style="display: flex; flex-direction: column; align-items: center; justify-content: center;">',
                        '            <details style="width: 100%;">',
                        '                <summary style="cursor: pointer; font-family: Chalkduster; font-size: 16px; margin-top: 5px; text-align: center;">See prompt</summary>',
                        f'                <div style="font-family: Chalkduster; font-size: 16px; margin-top: 5px; white-space: pre-wrap; text-align: center;">{_escape(prompts[row_idx])}</div>',
                        "            </details>",
                        "        </div>",
                        "    </div>",
                        "</div>",
                    ]
                )
                rows_html.append(prompt_html)
        return "\n".join(rows_html)

    def render_rotating_scripts() -> str:
        if not rotating_cols:
            return ""

        scripts: List[str] = ["<script>(function() {"]
        for col_idx, option_count in rotating_cols.items():
            var_name = f"currentIndex_{container_id}_{col_idx}"
            title_list = roundabout_titles.get(col_idx) or [
                f"(Click < or > to see more) Option {i+1}" for i in range(option_count)
            ]
            titles_js = "[" + ",".join(f'"{_escape(t)}"' for t in title_list) + "]"

            scripts.append(
                "\n".join(
                    [
                        f"var {var_name} = 0;",
                        f"var titles_{container_id}_{col_idx} = {titles_js};",
                        f"function update_{container_id}_{col_idx}() {{",
                        f'    var titleEl = document.getElementById("{container_id}_{col_idx}_title");',
                        f"    if (titleEl) {{ titleEl.textContent = titles_{container_id}_{col_idx}[{var_name}]; }}",
                        f"    for (var r = 0; r < {len(video_rows)}; r++) {{",
                        f"        for (var k = 0; k < {option_count}; k++) {{",
                        f'            var elem = document.getElementById("{container_id}_r" + r + "_c{col_idx}_k" + k);',
                        "            if (!elem) continue;",
                        f"            if (k === {var_name}) {{",
                        '                elem.style.display = "block"; if (elem.play) { try { elem.play(); } catch (e) {} }',
                        "            } else {",
                        '                elem.style.display = "none"; if (elem.pause) { try { elem.pause(); } catch (e) {} }',
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        f"window.rotateLeft_{container_id}_{col_idx} = function() {{",
                        f"    {var_name} = ({var_name} - 1 + {option_count}) % {option_count};",
                        f"    update_{container_id}_{col_idx}();",
                        "};",
                        f"window.rotateRight_{container_id}_{col_idx} = function() {{",
                        f"    {var_name} = ({var_name} + 1) % {option_count};",
                        f"    update_{container_id}_{col_idx}();",
                        "};",
                        "if (document.readyState === 'loading') {",
                        f"    document.addEventListener('DOMContentLoaded', update_{container_id}_{col_idx});",
                        "} else {",
                        f"    update_{container_id}_{col_idx}();",
                        "}",
                    ]
                )
            )
        scripts.append("})();</script>")
        return "\n".join(scripts)

    header_html = render_header_row()
    grid_html = render_rows()
    scripts_html = render_rotating_scripts()

    section_lines = [
        '<hr style="max-width: 1400px;">',
        '<div class="container" style="max-width: 1400px; display: flex; justify-content: center;">',
        '    <div class="row">',
        '        <div class="col-md-12">',
        f'            <h2 class="text-center" style="margin-bottom: 30px; margin-top: 10px;">{_escape(title)}</h2>',
        f'            <p style="margin-bottom: 30px; margin-bottom: 30px; text-align: center;">{_escape(description)}</p>',
        '            <div id="titledgrid" class="containershadow center" style="overflow-x: auto; overflow-y: auto; max-width: 1400px; margin: auto;">',
        _indent_block(header_html, 3),
        _indent_block(grid_html, 3),
        "            </div>",
        _indent_block(scripts_html, 2) if scripts_html else "",
        "        </div>",
        "    </div>",
        "</div>",
    ]

    return "\n".join(line for line in section_lines if line)


def main():
    website_html = build_video_grid_section(
    title="Real Video Editing with Input Video Guidance and Reference Effect Video Guidance",
    description="We can use variants of classifier free guidance in the direction of <b><strong>(left to right)</strong></b> the input video or <b><strong>(top to bottom)</strong></b> the reference effect video to guide the video editing process when editing real videos. As more input video guidance is applied, the video more closely resembles the input video (i.e. the top right corner of the grid). As more reference effect video guidance is applied, the video more closely resembles the reference effect video (i.e. the bottom left corner of the grid, notice the hair change and the sweater from the reference effect video). By interpolating between these two, we give users more control over the video editing process.",
    video_rows=[["./videos/hulk_videos/reference_effect.mp4", "./videos/hulk_videos/input.mp4"]], # [[f"./videos/hulk_videos/hulk_{i}_{j}.mp4" for i in range(4)] for j in range(4)],
    # prompts: Optional[List[str]] = None,
    column_headers = ["Reference Effect Video", "Input Video"],
    # roundabout_titles: Optional[Dict[int, List[str]]] = None,
    # container_id: Optional[str] = None,
    )
    with open("website_part.html", "w") as f:
        f.write(website_html)
    exit(0)

    website_html = build_video_grid_section(
    title="Real Video Editing with Input Video Guidance and Reference Effect Video Guidance",
    description="We can use variants of classifier free guidance in the direction of <b><strong>(left to right)</strong></b> the input video or <b><strong>(top to bottom)</strong></b> the reference effect video to guide the video editing process when editing real videos. As more input video guidance is applied, the video more closely resembles the input video (i.e. the top right corner of the grid). As more reference effect video guidance is applied, the video more closely resembles the reference effect video (i.e. the bottom left corner of the grid, notice the hair change and the sweater from the reference effect video). By interpolating between these two, we give users more control over the video editing process.",
    video_rows=[["./videos/hulk_videos/hulk_grid.mp4"]], # [[f"./videos/hulk_videos/hulk_{i}_{j}.mp4" for i in range(4)] for j in range(4)],
    # prompts: Optional[List[str]] = None,
    # column_headers: Optional[List[str]] = None,
    # roundabout_titles: Optional[Dict[int, List[str]]] = None,
    # container_id: Optional[str] = None,
    )
    with open("website_part.html", "w") as f:
        f.write(website_html)

if __name__ == "__main__":
    main()